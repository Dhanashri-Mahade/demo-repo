<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="SpringBoot SSR PRO - API Development Guide">
    <title>üî∂ SpringBoot SSR PRO</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Sidebar Navigation -->
    <nav id="sidebar">
        <div class="nav-header">
            <h2>üìö Contents</h2>
            <button id="closeSidebar" class="close-btn">&times;</button>
        </div>
        <ul class="nav-links">
            <li><a href="#intro">Introduction</a></li>
            <li><a href="#dto">1Ô∏è‚É£ DTO</a></li>
            <li><a href="#entity">2Ô∏è‚É£ Entity</a></li>
            <li><a href="#mapper">3Ô∏è‚É£ Mapper</a></li>
            <li><a href="#repository">4Ô∏è‚É£ Repository</a></li>
            <li><a href="#service">5Ô∏è‚É£ Service</a></li>
            <li><a href="#controller">6Ô∏è‚É£ Controller</a></li>
            <li><a href="#flow">API Flow</a></li>
            <li><a href="#fastapi">FastAPI Basics</a></li>
            <li><a href="#flask">Flask Basics</a></li>
            <li><a href="#testing">API Testing</a></li>
            <li><a href="#setup">Setup Instructions</a></li>
            <li><a href="#model">Model (SQLAlchemy)</a></li>
            <li><a href="#schemas">Schemas (Pydantic)</a></li>
            <li><a href="#router">Router (Endpoints)</a></li>
            <li><a href="#crud">CRUD Layer</a></li>
            <li><a href="#important">Important Concepts</a></li>
        </ul>
    </nav>

    <!-- Mobile Menu Button -->
    <button id="menuBtn" class="menu-btn">‚ò∞ Menu</button>

    <!-- Main Content -->
    <main id="mainContent">
        <header>
            <h1>üî∂ SpringBoot SSR PRO</h1>
        </header>

        <section id="intro">
            <p>"Before building any API in Spring Boot, we must follow a fixed structure.<br>
            This is compulsory in SSRpro so that our backend stays clean, consistent, and maintainable."</p>

            <p>We create <strong>six files</strong> for every API:</p>

            <p><strong>1) DTO<br>
            2) Entity<br>
            3) Mapper<br>
            4) Repository<br>
            5) Service<br>
            6) Controller</strong></p>

            <p>Now I will explain each file, its purpose, and what exactly should be written inside.</p>
        </section>

        <hr>

        <section id="dto">
            <h2>‚≠ê 1Ô∏è‚É£ DTO (Data Transfer Object)</h2>
            
            <p><strong>File Example:</strong> <code>TxnItemMtsDTO.java</code><br>
            Reference:</p>

            <h3>Purpose</h3>
            <p>DTO is the structure of data that goes <strong>in</strong> and <strong>out</strong> of your API.</p>
            
            <p>DTO is used for:</p>
            <ul>
                <li>Receiving input from frontend</li>
                <li>Sending output back as API response</li>
                <li>Preventing direct exposure of Entity structure</li>
            </ul>

            <h3>What goes inside a DTO?</h3>
            <p>‚úî Only fields (variables)<br>
            ‚úî Constructors<br>
            ‚úî Getters + Setters<br>
            ‚úî toString() method<br>
            ‚ùå No business logic<br>
            ‚ùå No database logic</p>

            <h3>How to explain to interns:</h3>
            <p>"DTO is like a clean package of data.<br>
            Whatever we send to the API or receive from the API will be inside the DTO."</p>
        </section>

        <hr>

        <section id="entity">
            <h2>‚≠ê 2Ô∏è‚É£ Entity</h2>
            
            <p><strong>File Example:</strong> <code>TxnItemMtsEntity.java</code><br>
            Reference:</p>

            <h3>Purpose</h3>
            <p>Entity represents the <strong>actual MySQL table</strong>.</p>

            <h3>What goes inside an Entity?</h3>
            <p>‚úî <code>@Entity</code> annotation<br>
            ‚úî <code>@Table(name="table_name")</code><br>
            ‚úî All table columns using <code>@Column(name="")</code><br>
            ‚úî Primary key using <code>@Id</code> + <code>@GeneratedValue</code><br>
            ‚úî Correct data types<br>
            ‚úî Getters + Setters</p>

            <h3>Entity Rules:</h3>
            <ul>
                <li>Column names <strong>must match exactly</strong> with DB</li>
                <li>No business logic</li>
                <li>No calculations</li>
                <li>CamelCase variables but DB uses snake_case</li>
            </ul>

            <h3>How to explain to interns:</h3>
            <p>"Entity is literally your database table in Java form.<br>
            One row in the table = one object of Entity class."</p>
        </section>

        <hr>

        <section id="mapper">
            <h2>‚≠ê 3Ô∏è‚É£ Mapper (MapStruct)</h2>
            
            <p><strong>File Example:</strong> <code>TxnItemMtsMapper.java</code><br>
            Reference:</p>

            <h3>Purpose</h3>
            <p>Mapper converts:</p>
            <ul>
                <li>DTO ‚Üí Entity</li>
                <li>Entity ‚Üí DTO</li>
                <li>Update DTO ‚Üí Existing Entity</li>
            </ul>

            <h3>What goes inside Mapper?</h3>
            <p>‚úî <code>@Mapper(componentModel="spring")</code><br>
            ‚úî <code>toDTO(entity)</code><br>
            ‚úî <code>toEntity(dto)</code><br>
            ‚úî Partial update using <code>@MappingTarget</code><br>
            ‚ùå No business logic<br>
            ‚ùå No manual field mapping elsewhere</p>

            <h3>Why Mapper is important?</h3>
            <p>Because mapping manually in service/controller causes:</p>
            <ul>
                <li>code duplication</li>
                <li>errors</li>
                <li>messy logic</li>
            </ul>
            <p>MapStruct automates mapping cleanly.</p>

            <h3>How to explain to interns:</h3>
            <p>"Mapper is like a translator between DTO and Entity.<br>
            Mapper ensures your API always returns DTOs, never raw entities."</p>
        </section>

        <hr>

        <section id="repository">
            <h2>‚≠ê 4Ô∏è‚É£ Repository (Database Layer)</h2>
            
            <p><strong>File Example:</strong> <code>TxnItemMtsRepository.java</code><br>
            Reference:</p>

            <h3>Purpose</h3>
            <p>Repository talks directly with the database.</p>

            <h3>What goes inside Repository?</h3>
            <p>‚úî Must extend <code>JpaRepository&lt;Entity, ID&gt;</code><br>
            ‚úî Custom queries using <code>@Query</code> (only if needed)<br>
            ‚úî Native SQL allowed when required<br>
            ‚ùå No business logic<br>
            ‚ùå No calculations</p>

            <h3>How to explain to interns:</h3>
            <p>"Repository is your direct connection to the database.<br>
            Whenever you want to fetch, save, update, or delete data ‚Äî the service layer uses repository."</p>
        </section>

        <hr>

        <section id="service">
            <h2>‚≠ê 5Ô∏è‚É£ Service (Business Logic)</h2>
            
            <p><strong>File Example:</strong> <code>TxnItemMtsService.java</code><br>
            Reference:</p>

            <h3>Purpose</h3>
            <p>Service contains the <strong>actual logic</strong> of your API.</p>

            <h3>What goes inside Service?</h3>
            <p>‚úî CRUD logic<br>
            ‚úî Validation<br>
            ‚úî Mapper conversions<br>
            ‚úî Combining data from multiple tables<br>
            ‚úî Error handling</p>

            <h3>What must NOT be inside service:</h3>
            <p>‚ùå No HTTP request/response handling<br>
            ‚ùå No DB queries directly<br>
            ‚ùå No controller-level details</p>

            <h3>Clean Service Rules:</h3>
            <ul>
                <li>Always return <strong>DTOs</strong>, never entities</li>
                <li>Do all logic here</li>
                <li>Keep controller clean</li>
            </ul>

            <h3>How to explain to interns:</h3>
            <p>"Service is the brain of your API.<br>
            If your API needs to apply some rules or calculations, it happens in the service layer."</p>
        </section>

        <hr>

        <section id="controller">
            <h2>‚≠ê 6Ô∏è‚É£ Controller (API Layer)</h2>
            
            <p><strong>File Example:</strong> <code>TxnItemMtsController.java</code><br>
            Reference:</p>

            <h3>Purpose</h3>
            <p>Controller exposes actual APIs to the frontend.</p>

            <h3>What goes inside Controller?</h3>
            <p>‚úî <code>@RestController</code><br>
            ‚úî <code>@RequestMapping("/api/...")</code><br>
            ‚úî Endpoints:</p>
            <ul>
                <li>GET</li>
                <li>POST</li>
                <li>PUT</li>
                <li>DELETE</li>
            </ul>
            <p>‚úî Calls service methods<br>
            ‚ùå No business logic inside controller</p>

            <h3>Controller Rules:</h3>
            <ul>
                <li>Must return <code>ResponseEntity&lt;DTO&gt;</code></li>
                <li>Must not write logic inside controller</li>
                <li>Must keep code readable</li>
            </ul>

            <h3>How to explain to interns:</h3>
            <p>"Controller is the API gateway.<br>
            Frontend will only interact with the controller.<br>
            The controller receives request ‚Üí passes it to service ‚Üí returns response."</p>
        </section>

        <hr>

        <section id="flow">
            <h2>‚≠ê Putting It All Together ‚Äî Full API Flow</h2>
            
            <p>Explain this slowly:</p>
            
            <p>"When frontend calls an API, this happens behind the scenes:</p>
            
            <p><strong>Request ‚Üí Controller ‚Üí Service ‚Üí Repository ‚Üí Database<br>
            Database ‚Üí Repository ‚Üí Service ‚Üí Controller ‚Üí Response</strong></p>

            <p>DTO = input/output<br>
            Entity = database table<br>
            Mapper = converter<br>
            Repository = database access<br>
            Service = logic<br>
            Controller = API endpoints"</p>

            <p>This flow is visible clearly in your SSRpro example files.<br>
            (Interns should follow the exact same structure.)</p>
        </section>

        <hr>
        <hr>

        <section id="code-explanation">
            <h2># IMP : Code EXplaination</h2>
        </section>

        <hr>

        <section id="fastapi">
            <h2>‚≠ê 1Ô∏è‚É£ FastAPI Basics (Simple Explanation Script)</h2>

            <h3>üîπ What is FastAPI?</h3>
            <p>"FastAPI is a Python framework used to build backend APIs very quickly.<br>
            It is modern, lightweight, and extremely fast ‚Äî almost as fast as Node.js and Go.<br>
            That's why many companies prefer it."</p>

            <hr>

            <h3>üîπ Why FastAPI is used?</h3>
            <p>Tell them:</p>
            <ul>
                <li>It is <strong>very fast</strong> (built on top of ASGI)</li>
                <li>Supports <strong>async</strong> code (non-blocking)</li>
                <li>Very easy to learn</li>
                <li>Automatically generates swagger API docs</li>
                <li>Strong request validation using Pydantic</li>
                <li>Less boilerplate code than Flask or Django</li>
            </ul>

            <p>Short line to say:</p>
            <p>"FastAPI lets you build APIs in minutes, not hours."</p>

            <hr>

            <h3>üîπ Fast Routing</h3>
            <p>"In FastAPI, creating a route is extremely simple."</p>
            <p>Example:</p>
            <pre><code>from fastapi import FastAPI

app = FastAPI()

@app.get("/hello")
def say_hello():
    return {"message": "Hello World"}</code></pre>
            <p>Just one decorator = one API route.</p>

            <hr>

            <h3>üîπ Pydantic Models (like DTO)</h3>
            <p>Explain in simple terms:</p>
            <p>"In Spring Boot, we create DTO classes.<br>
            In FastAPI, we create <strong>Pydantic Models</strong> for input/output."</p>
            <p>Example:</p>
            <pre><code>from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int</code></pre>
            <p>This validates the request automatically:</p>
            <ul>
                <li>wrong type ‚Üí error</li>
                <li>missing field ‚Üí error</li>
            </ul>

            <hr>

            <h3>üîπ Creating simple endpoints</h3>
            <p>Example:</p>
            <pre><code>@app.post("/user")
def create_user(user: User):
    return {"status": "saved", "data": user}</code></pre>
            <ul>
                <li>Request body automatically maps to Pydantic model</li>
                <li>FastAPI performs validation</li>
                <li>JSON response is auto-generated</li>
            </ul>

            <hr>

            <h3>üîπ Automatic Docs</h3>
            <p>Explain this clearly:</p>
            <p>"When you run FastAPI, you get 2 automatic documentation pages:"</p>
            <ul>
                <li><strong>Swagger UI:</strong><br>
                <code>http://localhost:8000/docs</code></li>
                <li><strong>Redoc:</strong><br>
                <code>http://localhost:8000/redoc</code></li>
            </ul>
            <p>"No need to manually create documentation; FastAPI does it for you."</p>
        </section>

        <hr>
        <hr>

        <section id="flask">
            <h2>‚≠ê 2Ô∏è‚É£ Flask Basics (Simple Explanation Script)</h2>

            <h3>üîπ What is Flask?</h3>
            <p>"Flask is a lightweight Python framework for backend development.<br>
            It is older than FastAPI and very simple to use."</p>

            <hr>

            <h3>üîπ When Flask is used?</h3>
            <p>Use this explanation:</p>
            <ul>
                <li>When you need simple APIs</li>
                <li>When project is small or medium</li>
                <li>When you don't need high-performance async APIs</li>
                <li>Ideal for educational or small internal tools</li>
            </ul>

            <hr>

            <h3>üîπ Simple Routing Example</h3>
            <pre><code>from flask import Flask

app = Flask(__name__)

@app.route("/hello")
def hello():
    return {"message": "Hello World"}</code></pre>
            <p>Flask routing is also simple but less structured compared to FastAPI.</p>

            <hr>

            <h3>üîπ Differences Between FastAPI & Flask (Explain in one line each)</h3>
            <p>Tell interns:</p>

            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>FastAPI</th>
                            <th>Flask</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Speed</td>
                            <td>Very fast (async)</td>
                            <td>Moderate</td>
                        </tr>
                        <tr>
                            <td>Validation</td>
                            <td>Built-in (Pydantic)</td>
                            <td>Manual required</td>
                        </tr>
                        <tr>
                            <td>Auto Docs</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td>Modern</td>
                            <td>Yes</td>
                            <td>Older</td>
                        </tr>
                        <tr>
                            <td>Structure</td>
                            <td>Consistent</td>
                            <td>Flexible (can become messy)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p><strong>Short summary to speak:</strong><br>
            "FastAPI is faster, more modern, and gives automatic validation + documentation.<br>
            Flask is simpler but requires more manual work."</p>
        </section>

        <hr>
        <hr>

        <section id="testing">
            <h2>‚≠ê 3Ô∏è‚É£ API Testing</h2>

            <h3>üîπ Swagger for FastAPI</h3>
            <p>"Swagger is built-in. Just open:<br>
            <code>/docs</code><br>
            and test GET/POST/PUT/DELETE directly."</p>

            <h3>üîπ Response Models</h3>
            <p>"When we use Pydantic models in response, FastAPI:</p>
            <ul>
                <li>auto-formats JSON</li>
                <li>ensures correct data types</li>
                <li>validates output</li>
                <li>generates schema for Swagger"</li>
            </ul>

            <p>Example:</p>
            <pre><code>from pydantic import BaseModel

class ResponseUser(BaseModel):
    id: int
    name: str</code></pre>
            <p>Now FastAPI will show this schema in Swagger UI.</p>
        </section>

        <hr>
        <hr>

        <section id="setup">
            <h2>‚≠ê 4Ô∏è‚É£ Setup Instructions (Short Steps)</h2>

            <h3>A) Setup for FastAPI</h3>

            <h4>Step 1: Create Virtual Environment</h4>
            <pre><code>python -m venv venv</code></pre>

            <h4>Step 2: Activate venv</h4>
            <p>Windows:</p>
            <pre><code>venv\Scripts\activate</code></pre>
            <p>Mac/Linux:</p>
            <pre><code>source venv/bin/activate</code></pre>

            <h4>Step 3: Install FastAPI + Uvicorn</h4>
            <pre><code>pip install fastapi uvicorn</code></pre>

            <h4>Step 4: Run FastAPI</h4>
            <pre><code>uvicorn main:app --reload</code></pre>

            <hr>

            <h3>B) Setup for Flask</h3>

            <h4>Step 1: Create Virtual Environment</h4>
            <pre><code>python -m venv venv</code></pre>

            <h4>Step 2: Activate venv</h4>
            <p>Windows:</p>
            <pre><code>venv\Scripts\activate</code></pre>
            <p>Mac/Linux:</p>
            <pre><code>source venv/bin/activate</code></pre>

            <h4>Step 3: Install Flask</h4>
            <pre><code>pip install flask</code></pre>

            <h4>Step 4: Run Flask</h4>
            <pre><code>python app.py</code></pre>

            <hr>

            <h3>‚≠ê Quick summary you can say in session:</h3>
            <ul>
                <li>"FastAPI = fast, modern, auto validation, auto documentation."</li>
                <li>"Flask = simple, easy to begin, but missing built-in validation and docs."</li>
                <li>"Both are good; choose based on project requirements."</li>
                <li>"Always create virtual environment before installing packages."</li>
                <li>"Always test APIs using Swagger (/docs) for FastAPI."</li>
            </ul>
        </section>

        <hr>

        <section id="detailed-explanation">
            <p>Senior, yeh <strong>perfect 10‚Äì12 minute ka explanation script</strong> hai jo tum interns ko directly bol sakti ho while showing your code.<br>
            Main tumhare code ko 4 main parts me divide karke explain karwa rahi hu:</p>

            <h3>‚úÖ 1) Model (SQLAlchemy Entity)</h3>
            <h3>‚úÖ 2) Schema (Pydantic DTO)</h3>
            <h3>‚úÖ 3) Router / API Endpoints</h3>
            <h3>‚úÖ 4) CRUD Functions</h3>
            <h3>+</h3>
            <h3>‚≠ê Important concepts jo unko jarur batane chahiye</h3>

            <p>Sab kuch simple language me, clean flow me.</p>
        </section>

        <hr>

        <section id="model">
            <h2>‚≠ê 1Ô∏è‚É£ MODEL (SQLAlchemy Entity) ‚Äî What to Explain</h2>

            <p>Tell interns:</p>
            <p>"Model file hamara <strong>database table ka structure</strong> hota hai.<br>
            Spring Boot me jaisa Entity hota hai, FastAPI me SQLAlchemy Model hota hai."</p>

            <h3>üî• Important Points to Explain</h3>

            <h4>‚úî Table definition</h4>
            <pre><code>class Jobs(Base):
    __tablename__ = "jobs"</code></pre>
            <ul>
                <li>Yeh table name database me exactly same hota hai.</li>
            </ul>

            <hr>

            <h4>‚úî Columns explained</h4>
            <p>Example:</p>
            <pre><code>job_id = Column(Integer, primary_key=True, index=True)
req_id = Column(String(50), nullable=False)
tags = Column(JSON)
workMode = Column(Enum('Remote', 'Hybrid', 'Office'))</code></pre>

            <p>Explain:</p>
            <ul>
                <li>Each column ‚Üí database field</li>
                <li><code>primary_key=True</code> means unique job entry</li>
                <li><code>nullable=False</code> means empty nahi chalega</li>
                <li><code>JSON</code> type means multiple values store kar sakte ho</li>
                <li><code>Enum</code> ‚Üí selected options only</li>
                <li><code>Text</code> ‚Üí long description</li>
            </ul>

            <hr>

            <h4>‚úî Foreign key + relationship</h4>
            <pre><code>created_by = Column(Integer, ForeignKey("admin.id"))
applications = relationship("Applications", back_populates="job")</code></pre>

            <p>Explain:</p>
            <ul>
                <li>Foreign key = connect to admin table</li>
                <li>Relationship = fetch related applications automatically</li>
            </ul>

            <hr>

            <h3>‚≠ê Script sentence to speak:</h3>
            <p>"Model means database table ka blueprint.<br>
            Line-by-line dekhkar samajho ki table me kya columns ban rahe hain, kis type ka data store hoga, aur relationships kaise maintain honge."</p>
        </section>

        <hr>

        <section id="schemas">
            <h2>‚≠ê 2Ô∏è‚É£ SCHEMAS (Pydantic Models / DTOs) ‚Äî What to Explain</h2>

            <p>Tell them:</p>
            <p>"Schema file hamara <strong>DTO layer</strong> hota hai, bilkul Spring Boot ke DTO ki tarah.<br>
            Ye hamare input-output ko validate karta hai."</p>

            <hr>

            <h3>‚úî What is JobBase?</h3>
            <pre><code>class JobBase(BaseModel):
    req_id: str
    jobName: str
    category: Optional[str]
    tags: Optional[List[str]]</code></pre>

            <p>Explain:</p>
            <ul>
                <li>Ye fields frontend se input me aayenge</li>
                <li>FastAPI automatically validation karega</li>
                <li>Wrong input ‚Üí error without writing custom code</li>
            </ul>

            <hr>

            <h3>‚úî JobCreate</h3>
            <pre><code>class JobCreate(JobBase):
    pass</code></pre>

            <p>Explain:</p>
            <ul>
                <li>Same structure ‚Äî used for POST / PUT</li>
                <li>Clean separation</li>
            </ul>

            <hr>

            <h3>‚úî Job Model (Response DTO)</h3>
            <pre><code>class Job(JobBase):
    job_id: int</code></pre>

            <p>Explain:</p>
            <ul>
                <li>Yeh output DTO hai</li>
                <li>It includes job_id</li>
                <li>Response me only validated data jayega</li>
            </ul>

            <hr>

            <h3>‚úî .from_orm()</h3>
            <p>Explain:</p>
            <ul>
                <li>SQLAlchemy model ko Pydantic model me convert karta hai</li>
                <li>Ensures clean, structured output</li>
            </ul>

            <hr>

            <h3>‚≠ê Script sentence:</h3>
            <p>"Schema file ensures frontend se aane wala data clean ho, correct ho, aur API response always structured ho."</p>
        </section>

        <hr>

        <section id="router">
            <h2>‚≠ê 3Ô∏è‚É£ ROUTER (API Endpoints) ‚Äî What to Explain</h2>

            <p>Tell interns:</p>
            <p>"Router hamara controller hota hai. Yaha par API routes define hote hain."</p>

            <hr>

            <h3>‚úî Create Job API</h3>
            <pre><code>@router.post("/create")</code></pre>

            <p>Explain:</p>
            <ul>
                <li>This endpoint creates new job</li>
                <li><code>Depends(get_current_admin)</code> ‚Üí authentication</li>
                <li><code>db_job = models.Jobs(**job.dict())</code> ‚Üí converting DTO to model</li>
            </ul>

            <h3>‚úî Auto date set</h3>
            <pre><code>if not job.created_date:
        db_job.created_date = date.today()</code></pre>

            <p>Explain:</p>
            <ul>
                <li>If frontend doesn't send a date ‚Üí set today by default</li>
            </ul>

            <hr>

            <h3>‚úî Add ‚Üí Commit ‚Üí Refresh</h3>
            <pre><code>db.add(db_job)
db.commit()
db.refresh(db_job)</code></pre>

            <p>Explain:</p>
            <ul>
                <li>Add = store request</li>
                <li>Commit = save permanently</li>
                <li>Refresh = get updated values</li>
            </ul>

            <hr>

            <h3>‚úî Response formatting</h3>
            <pre><code>pydantic_job = schemas.Job.from_orm(db_job)
return JSONResponse(content=jsonable_encoder(pydantic_job.model_dump()))</code></pre>

            <p>Explain:</p>
            <ul>
                <li>Convert output to DTO</li>
                <li>Send clean JSON back</li>
            </ul>

            <hr>

            <h3>‚≠ê GET All Jobs</h3>
            <pre><code>jobs = db.query(models.Jobs).all()</code></pre>

            <p>Explain:</p>
            <ul>
                <li>Simple fetch all</li>
                <li>Convert each row into DTO using list comprehension</li>
            </ul>

            <hr>

            <h3>‚≠ê UPDATE Job</h3>
            <pre><code>for key, value in updated_job.dict().items():
    setattr(job, key, value)</code></pre>

            <p>Explain:</p>
            <ul>
                <li>Update dynamically, no need to write field-by-field</li>
            </ul>

            <hr>

            <h3>‚≠ê DELETE Job</h3>
            <p>Explain:</p>
            <ul>
                <li>Check if exists ‚Üí delete ‚Üí commit</li>
            </ul>

            <hr>

            <h3>Script sentence:</h3>
            <p>"Router is the entry point of the API. Yaha par HTTP methods likhte hain, service/DB ko call karte hain, aur final JSON response return karte hain."</p>
        </section>

        <hr>

        <section id="crud">
            <h2>‚≠ê 4Ô∏è‚É£ CRUD Layer ‚Äî What to Explain</h2>

            <p>CRUD file is optional but good practice.</p>

            <p>Tell interns:</p>
            <p>"This file me pure database operations ko separate karte hain."</p>

            <p>Inside CRUD:</p>
            <ul>
                <li>create_job</li>
                <li>get_jobs</li>
                <li>get_job_by_id</li>
                <li>update_job</li>
                <li>delete_job</li>
            </ul>

            <p>Explain:</p>
            <p>"Yeh backend clean rakhta hai, taaki hamara controller simple dikhe."</p>
        </section>

        <hr>

        <section id="important">
            <h2>‚≠ê 5Ô∏è‚É£ MOST IMPORTANT THINGS TO TEACH INTERN</h2>

            <ol>
                <li>
                    <strong>Model = Database Table</strong>
                    <ul>
                        <li>table name</li>
                        <li>columns</li>
                        <li>relationships</li>
                    </ul>
                </li>
                <li>
                    <strong>Schema = DTO</strong>
                    <ul>
                        <li>validation</li>
                        <li>input / output structure</li>
                        <li>from_orm</li>
                    </ul>
                </li>
                <li>
                    <strong>Router = Controller</strong>
                    <ul>
                        <li>@router.get, post, put, delete</li>
                        <li>clean code</li>
                        <li>response formatting</li>
                    </ul>
                </li>
                <li>
                    <strong>CRUD = Database Logic</strong>
                    <ul>
                        <li>separate DB operations</li>
                    </ul>
                </li>
                <li>
                    <strong>JSON Response Format</strong>
                    <ul>
                        <li>Always clean structured output</li>
                    </ul>
                </li>
                <li>
                    <strong>Naming conventions</strong>
                    <ul>
                        <li>job_id, created_date ‚Üí snake_case for DB</li>
                        <li>jobId, createdDate ‚Üí camelCase for frontend if needed</li>
                    </ul>
                </li>
                <li>
                    <strong>Error Handling</strong>
                    <ul>
                        <li>404 not found</li>
                        <li>missing data</li>
                    </ul>
                </li>
                <li>
                    <strong>Auth Dependency</strong>
                    <pre><code>Depends(get_current_admin)</code></pre>
                    <p>Explain simple:<br>
                    "This ensures only admin can create/update/delete job."</p>
                </li>
            </ol>
        </section>

        <hr>

        <!-- Back to Top Button -->
        <button id="backToTop" class="back-to-top" title="Back to top">‚Üë</button>
    </main>

    <script src="script.js"></script>
</body>
</html>
